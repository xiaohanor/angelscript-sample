/**
 * Automatically places a line of meshes along a spline.
 */

event void FPropLineUpdatedEvent(UObject Object);

UCLASS(HideCategories = "Rendering Replication Collision Debug Input HLOD Actor LOD Cooking DataLayers WorldPartition Physics RayTracing TextureStreaming", Meta = (NoSourceLink, Keywords = "Spline"))
class APropLine : AHazeBaseProp
{
	default bRunConstructionScriptOnDrag = true;

	UPROPERTY(DefaultComponent, RootComponent)
	USceneComponent Root;
    default Root.Mobility = EComponentMobility::Static;

#if EDITORONLY_DATA
	access EditOnly = private, * (editdefaults), Prefab;

	UPROPERTY(DefaultComponent, Attach = Root)
	access:EditOnly
    UPropLineSplineComponent PropSpline;
	default PropSpline.bRenderWhileNotSelected = false;
	default PropSpline.EditingSettings.HeightIndicators = ESplineHeightIndicatorMode::None;
	default PropSpline.EditingSettings.SplineColor = FLinearColor(0.95, 0.62, 1.0);
	default PropSpline.EditingSettings.bSelectSplineComponentWhileEditing = false;
    default PropSpline.Mobility = EComponentMobility::Movable;
	default PropSpline.IsVisualizationComponent = false;
#endif

	UPROPERTY(Category = "Events")
	FPropLineUpdatedEvent OnPropLineUpdated;


#if EDITORONLY_DATA
	UPROPERTY(DefaultComponent, Attach = Root, ShowOnActor)
    UTagContainerComponent TagContainer;
    default TagContainer.Mobility = EComponentMobility::Static;
#endif

	// Which preset to use for this prop line
	UPROPERTY(EditAnywhere, Category = "Prop Line Preset")
	UPropLinePreset Preset = nullptr;

	// Which preset to use for this prop line
	UPROPERTY(EditAnywhere, Category = "Prop Line Preset")
	TArray<FPropLineMergedMeshData> MergedMeshes;

	// Non-preset prop line settings
	UPROPERTY(EditAnywhere, Category = "Prop Line", Meta = (ShowOnlyInnerProperties))
	FPropLineSettings Settings;

	// What kind of generation method to use for this prop line
	UPROPERTY(EditAnywhere, Category = "Prop Line Segments")
	EPropLineType Type = EPropLineType::StaticMeshes;

	// How to distribute meshes along the spline
	UPROPERTY(EditAnywhere, Category = "Prop Line Segments")
	EPropLineDistributionType MeshDistribution = EPropLineDistributionType::DistributePerSegment;

	// When to stretch meshes when they don't fit exactly into spline segments
	UPROPERTY(EditAnywhere, Category = "Prop Line Segments")
	EPropLineStretchType MeshStretching = EPropLineStretchType::StretchLastMeshInSegment;

	// Settings for each line segment in the prop line
	UPROPERTY(EditAnywhere, Category = "Prop Line Segments", Meta = (EditCondition = "Type == EPropLineType::PerSegment", EditConditionHides), EditFixedSize)
	TArray<FPropLineSegment> Segments;

	// Tweak the randomization seed of the meshes, different numbers create different randomization
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Prop Line Segments", AdvancedDisplay)
	int RandomizeTweak = 0;

	// Maximum size of each before splitting it up into different meshes
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Prop Line Segments", AdvancedDisplay)
	float MaximumMergedMeshSize = 10000.0;

	// Maximum amount of segments to merge into one merged mesh
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Prop Line Segments", AdvancedDisplay)
	int MaximumSegmentsPerMergedMesh = 200;

	// Maximum amount of meshes that are generated by the prop line, acts as a sanity check
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Prop Line Segments", AdvancedDisplay)
	int MaximumTotalMeshes = 1000;

	// Whether to automatically move the actor pivot to the position of the first spline point
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Prop Line Segments", AdvancedDisplay)
	bool bMoveActorPivotToFirstSplinePoint = true;

	// Whether created components should be shown in the details view
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Prop Line Segments", AdvancedDisplay)
	bool bShowMeshesInDetailsView = false;

	/**
	 * Set if gameplay logic uses the spline from this prop line.
	 * Without this, the propline's spline will be deleted during cooking, as it is not needed after the meshes are generated.
	 */
	UPROPERTY(EditAnywhere, Category = "Prop Line Segments", AdvancedDisplay)
	bool bGameplaySpline = false;

#if EDITORONLY_DATA
	// Whether this propline has been updated to use instance components yet
	UPROPERTY(EditAnywhere, Category = "Prop Line Internals")
	bool bIsUsingInstanceComponents = false;

	// Whether we've ever added the default mesh
	UPROPERTY(EditAnywhere, Category = "Prop Line Internals")
	bool bHasAddedDefaultMesh = false;
#endif

#if EDITOR
	UFUNCTION(BlueprintOverride)
	void OnActorPlacedInEditor()
	{
		Type = EPropLineType::SplineMeshes;
		MeshDistribution = EPropLineDistributionType::DistributeOverEntireSpline;
		MeshStretching = EPropLineStretchType::StretchAllMeshes;
	}

	UFUNCTION(BlueprintOverride)
	void OnActorModifiedInEditor()
	{
		if (bIsPropLineUpdating)
			return;

		// If we don't have any meshes configured in the editor, add the default mesh
		if (Settings.Meshes.Num() == 0 && !bHasAddedDefaultMesh)
		{
			FPropLineMesh DefaultMesh;
			DefaultMesh.Mesh.StaticMesh = Cast<UStaticMesh>(LoadObject(nullptr, "/Game/Environment/BasicShapes/DefaultMeshes/PropLineDefaultMesh.PropLineDefaultMesh"));

			Settings.Meshes.Add(DefaultMesh);
			bHasAddedDefaultMesh = true;
		}

		// PropLines should always have their actor pivot placed at the first spline point
		if (PropSpline.SplinePoints.Num() != 0 && bMoveActorPivotToFirstSplinePoint)
		{
			FVector SplinePointOrigin = PropSpline.SplinePoints[0].RelativeLocation;
			if (!SplinePointOrigin.IsNearlyZero())
			{
				for (FHazeSplinePoint& SplinePoint : PropSpline.SplinePoints)
					SplinePoint.RelativeLocation -= SplinePointOrigin;

				RootComponent.Modify();
				RootComponent.SetWorldLocation(PropSpline.WorldTransform.TransformPosition(SplinePointOrigin));
				PropSpline.Modify();
				PropSpline.SetRelativeLocation(FVector::ZeroVector);
			}
		}

		UpdatePropLine();
	}
#endif

#if EDITORONLY_DATA
	bool bIsPropLineUpdating = false;
	void UpdatePropLine(bool bFromConstructionScript = false)
	{
		if (bIsPropLineUpdating)
			return;

		FPropLineUpdateScope UpdateScope(this);

		//float Time = Time::PlatformTimeSeconds;

		// The first time we update not from construction script, switch to instance components
		if (!bFromConstructionScript)
			bIsUsingInstanceComponents = true;

		// Apply the preset if we have one
		if (Preset != nullptr)
			Settings = Preset.Settings;

		// Update the spline if we're reconstructing while selected
		PropSpline.UpdateSpline();

		// Update segment configuration
		PrepareSegments();

		// Create the Segment Meshes
		FPropLineMeshGenerationContext GenContext;
		GenContext.Params = FPropLineGenerationParams::FromPropLine(this);
		GenContext.Actor = this;
		GenContext.PropSpline = PropSpline;
		GenContext.TagContainer = TagContainer;

		// Collect all the existing components we might want to reuse
		if (bIsUsingInstanceComponents)
		{
			TArray<UHazePropComponent> PropComponents;
			GetComponentsByClass(PropComponents);

			for (auto PropComp : PropComponents)
			{
				if (PropComp.ComponentCreationMethod == EComponentCreationMethod::Instance)
					GenContext.UnusedExistingComponents.Add(PropComp.Name, PropComp);
			}

			TArray<UHazePropSplineMeshComponent> SplinePropComponents;
			GetComponentsByClass(SplinePropComponents);

			for (auto PropComp : SplinePropComponents)
			{
				if (PropComp.ComponentCreationMethod == EComponentCreationMethod::Instance)
					GenContext.UnusedExistingComponents.Add(PropComp.Name, PropComp);
			}
		}

		if (MergedMeshes.Num() == 0)
		{
#if EDITOR
			// When we're dragging a spline point or the actor as a whole, don't update collision until
			// we release the drag operation. Updating collision is slow and would make the dragging laggy.
			if (Editor::IsSelected(this))
			{
				UHazeSplineSelection SplineSelection = GetGlobalSplineSelection();
				if (SplineSelection.bIsDraggingWidget)
					GenContext.bUpdateSplineMeshCollision = false;
				if (IsActorBeingMovedInEditor())
					GenContext.bUpdateSplineMeshCollision = false;
			}
#endif

			GenContext.Generate();
		}
		else
		{
			// Since we have a merged mesh, use that instead
			for (int i = 0, Count = MergedMeshes.Num(); i < Count; ++i)
			{
				FPropLineMergedMeshData MergedData = MergedMeshes[i];
				if (MergedData.StaticMesh == nullptr)
					continue;

				FHazePropSettings PropSettings;
				PropSettings.StaticMesh = MergedData.StaticMesh;

				auto MergedComp = Cast<UHazePropComponent>(
					GenContext.GetOrGenerateComponent(
						UHazePropComponent,
						FName(f"MergedMesh_{i}")));

				MergedComp.Mobility = RootComponent.Mobility;
				MergedComp.AttachToComponent(RootComponent);
				MergedComp.SetLightmapType(ELightmapType::ForceSurface);
				MergedComp.ConfigureFromConstructionScript(PropSettings);
				MergedComp.SetRelativeTransform(MergedData.RelativeTransform);
			}
		}

		// Any existing components that weren't used by the generation should be destroyed
		for (auto CompIterator : GenContext.UnusedExistingComponents)
			Editor::DestroyAndRenameInstanceComponentInEditor(CompIterator.Value);

		if (bGameplaySpline)
		{
			PropSpline.EditingSettings.SplineColor = FLinearColor(0.21, 0.95, 0.21);
		}
		else
		{
			if (MergedMeshes.Num() != 0)
				PropSpline.EditingSettings.SplineColor = FLinearColor(1.00, 0.60, 0.00);
			else
				PropSpline.EditingSettings.SplineColor = FLinearColor(0.95, 0.62, 1.0);
		}

		//float EndTime = Time::PlatformTimeSeconds;
		//Log(f"Update {Name} took {EndTime - Time :.4f} seconds");

		OnPropLineUpdated.Broadcast(this);
	}

	UFUNCTION(BlueprintOverride)
	void ConstructionScript()
	{
		// If we're cooking a gameplay spline, copy the editor-only PropSpline into a new spline
		if (Editor::IsCooking() && bGameplaySpline)
		{
			auto GameplaySpline = UHazeSplineComponent::Create(this, n"GameplaySpline");
			GameplaySpline.SplinePoints = PropSpline.SplinePoints;
			GameplaySpline.SplineSettings = PropSpline.SplineSettings;
			GameplaySpline.EditingSettings = PropSpline.EditingSettings;
			GameplaySpline.ComputedSpline = PropSpline.ComputedSpline;
			GameplaySpline.bSpecifyConnections = PropSpline.bSpecifyConnections;
			GameplaySpline.EndConnection = PropSpline.EndConnection;
			GameplaySpline.StartConnection = PropSpline.StartConnection;
			GameplaySpline.bAlignLastPointToEndConnection = PropSpline.bAlignLastPointToEndConnection;
			GameplaySpline.bAlignFirstPointToStartConnection = PropSpline.bAlignFirstPointToStartConnection;
		}

		if (!bIsUsingInstanceComponents)
		{
			if (Editor::IsCooking() || World.IsGameWorld())
			{
				// If this propline isn't using instance components yet at cook time, fall
				// back to using construction script components for now
				UpdatePropLine(true);
			}
			else
			{
#if EDITOR
				// We've opened this level in the editor, so we should queue it up to be switched to instance components
				auto PropLineSubsystem = UPropLineEditorSubsystem::Get();
				PropLineSubsystem.PropLinesPendingUpdate.Add(this);
#endif
			}
		}
	}

	void PrepareSegments()
	{
		// Add new entries 
		for (int i = Segments.Num(); i < PropSpline.ComputedSpline.Segments.Num(); ++i)
		{
			if (i == 0)
				Segments.Add(FPropLineSegment());
			else
				Segments.Add(Segments.Last());
		}

		// Remove old entries
		Segments.SetNum(PropSpline.ComputedSpline.Segments.Num());
	}

	EPropLineSegmentType GetSegmentType(int SegmentIndex) const
	{
		if (Type == EPropLineType::StaticMeshes)
			return EPropLineSegmentType::StaticMesh;
		else if (Type == EPropLineType::StaticMeshesCurvedPlacement)
			return EPropLineSegmentType::StaticMeshCurvedPlacement;
		else if (Type == EPropLineType::SplineMeshes)
			return EPropLineSegmentType::SplineMesh;
		
		if (Segments.IsValidIndex(SegmentIndex))
			return Segments[SegmentIndex].Type;
		return EPropLineSegmentType::StaticMesh;
	}

	bool IsSegmentStraight(int SegmentIndex) const
	{
		if (Type == EPropLineType::StaticMeshes)
			return true;
		else if (Type == EPropLineType::StaticMeshesCurvedPlacement)
			return false;
		else if (Type == EPropLineType::SplineMeshes)
			return false;
		
		if (Segments.IsValidIndex(SegmentIndex))
			return Segments[SegmentIndex].Type == EPropLineSegmentType::StaticMesh;
		return true;
	}

	UFUNCTION(BlueprintOverride)
	void GetReferencedContentObjects(TArray<UObject>& Objects) const
	{
		for (auto Mesh : Settings.Meshes)
		{
			if (Mesh.Mesh.StaticMesh != nullptr)
				Objects.Add(Mesh.Mesh.StaticMesh);
		}

		if (Settings.Standard.Mesh.StaticMesh != nullptr)
			Objects.Add(Settings.Standard.Mesh.StaticMesh);
		if (Settings.Corner.Mesh.StaticMesh != nullptr)
			Objects.Add(Settings.Corner.Mesh.StaticMesh);
		if (Settings.Start.Mesh.StaticMesh != nullptr)
			Objects.Add(Settings.Start.Mesh.StaticMesh);
		if (Settings.End.Mesh.StaticMesh != nullptr)
			Objects.Add(Settings.End.Mesh.StaticMesh);
	}

	UFUNCTION()
	void InitializeFromStaticMesh(UStaticMesh Mesh)
	{
		FPropLineMesh DefaultMesh;
		DefaultMesh.Mesh.StaticMesh = Mesh;

		Settings.Meshes.Reset();
		Settings.Meshes.Add(DefaultMesh);
		PropSpline.SplinePoints[1].RelativeLocation = FVector(100.0, 0.0, 0.0);
	}

	UFUNCTION()
	void InitializeFromPropSettings(FHazePropSettings PropSettings)
	{
		FPropLineMesh DefaultMesh;
		DefaultMesh.Mesh = PropSettings;

		Settings.Meshes.Reset();
		Settings.Meshes.Add(DefaultMesh);
		PropSpline.SplinePoints[1].RelativeLocation = FVector(100.0, 0.0, 0.0);
	}
#endif
};

UCLASS(NotPlaceable)
class UPropLineSplineComponent : UHazeSplineComponent
{
#if EDITORONLY_DATA
	TArray<FHazeSplinePoint> OriginalPoints;

	void UpdateSpline() override
	{
		PrepareSpline();
		Super::UpdateSpline();
		ForceComputedTangents();
		ResetSpline();
	}

	void ForceComputedTangents()
	{
		APropLine PropLine = Cast<APropLine>(Owner);
		if (PropLine == nullptr)
			return;

		for (int i = 0, Count = ComputedSpline.Points.Num() - 1; i < Count; ++i)
		{
			if (PropLine.GetSegmentType(i) == EPropLineSegmentType::StaticMesh)
			{
				ComputedSpline.Points[i+1].ArriveTangent_Rotation = ComputedSpline.Points[i].LeaveTangent_Rotation;
				ComputedSpline.Points[i+1].ArriveTangent_Scale = ComputedSpline.Points[i].LeaveTangent_Scale;
			}
		}
	}

	void PrepareSpline()
	{
		APropLine PropLine = Cast<APropLine>(Owner);
		if (PropLine == nullptr)
			return;

		OriginalPoints = SplinePoints;

		int PointCount = SplinePoints.Num();
		if (PointCount <= 1)
			return;

		for (int PointIndex = 0; PointIndex < PointCount; ++PointIndex)
		{
			FHazeSplinePoint& Point = SplinePoints[PointIndex];

			// Always override tangents
			bool bOriginalOverride = Point.bOverrideTangent;
			Point.bOverrideTangent = true;
			Point.bDiscontinuousTangent = true;

			// Override tangents for non-curved segments to be straight
			if (PropLine.GetSegmentType(PointIndex) == EPropLineSegmentType::StaticMesh)
			{
				if (SplinePoints.IsValidIndex(PointIndex+1))
					Point.LeaveTangent = SplinePoints[PointIndex+1].RelativeLocation - Point.RelativeLocation;
				else
					Point.LeaveTangent = FVector::ZeroVector;
			}
			else if (Point.LeaveTangent.IsNearlyZero() || !bOriginalOverride)
			{
				FVector ArriveTangent;
				SplineComputation::ComputeAutoTangentForPoint(
					SplineSettings, SplinePoints,
					PointIndex,
					ArriveTangent,
					Point.LeaveTangent
				);
			}

			if (PropLine.GetSegmentType(PointIndex-1) == EPropLineSegmentType::StaticMesh)
			{
				if (SplinePoints.IsValidIndex(PointIndex-1))
					Point.ArriveTangent = Point.RelativeLocation - SplinePoints[PointIndex-1].RelativeLocation;
				else
					Point.ArriveTangent = FVector::ZeroVector;
			}
			else if (Point.ArriveTangent.IsNearlyZero() || !bOriginalOverride)
			{
				FVector LeaveTangent;
				SplineComputation::ComputeAutoTangentForPoint(
					SplineSettings, SplinePoints,
					PointIndex,
					Point.ArriveTangent,
					LeaveTangent
				);
			}
		}
	}

	void ResetSpline()
	{
		APropLine PropLine = Cast<APropLine>(Owner);
		if (PropLine == nullptr)
			return;

		SplinePoints = OriginalPoints;

		int PointCount = SplinePoints.Num();
		if (PointCount <= 1)
			return;

		for (int PointIndex = 0; PointIndex < PointCount; ++PointIndex)
		{
			FHazeSplinePoint& Point = SplinePoints[PointIndex];

			bool bNextSegmentStraight = false;
			if (PointIndex < PointCount-1 || IsClosedLoop())
				bNextSegmentStraight = PropLine.IsSegmentStraight(PointIndex % (PointCount-1));
			else
				bNextSegmentStraight = PropLine.IsSegmentStraight(PointIndex-1);

			bool bPrevSegmentStraight = false;
			if (PointIndex > 0 || IsClosedLoop())
				bPrevSegmentStraight = PropLine.IsSegmentStraight((PointIndex-1+PointCount) % PointCount);
			else
				bPrevSegmentStraight = PropLine.IsSegmentStraight(PointIndex % PointCount);

			if (bNextSegmentStraight != bPrevSegmentStraight)
				Point.bDiscontinuousTangent = true;
			else if (!Point.bOverrideTangent)
				Point.bDiscontinuousTangent = false;
		}
	}
#endif

#if EDITOR
	void CheckUsableGameplaySpline() const
	{
		if (!World.IsGameWorld())
			return;
		APropLine PropLine = Cast<APropLine>(Owner);
		if (PropLine.bGameplaySpline)
			return;
		if (GetGlobalSplineSelection().bIsRunningSplineEditorCode)
			return;

		devError(f"Cannot use propline spline {Owner.ActorNameOrLabel} for gameplay unless the 'Gameplay Spline' checkbox is checked.");
	}

	float GetSplineLength() const property override
	{
		CheckUsableGameplaySpline();
		return Super::GetSplineLength();
	}

	FVector GetWorldLocationAtSplineFraction(float Fraction) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldLocationAtSplineFraction(Fraction);
	}

	FQuat GetWorldRotationAtSplineFraction(float Fraction) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldRotationAtSplineFraction(Fraction);
	}

	FVector GetWorldScale3DAtSplineFraction(float Fraction) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldScale3DAtSplineFraction(Fraction);
	}

	FTransform GetWorldTransformAtSplineFraction(float Fraction) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldTransformAtSplineFraction(Fraction);
	}

	FVector GetWorldLocationAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldLocationAtSplineDistance(SplineDistance);
	}

	FQuat GetWorldRotationAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldRotationAtSplineDistance(SplineDistance);
	}

	FVector GetWorldScale3DAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldScale3DAtSplineDistance(SplineDistance);
	}

	FTransform GetWorldTransformAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldTransformAtSplineDistance(SplineDistance);
	}

	FVector GetWorldTangentAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldTangentAtSplineDistance(SplineDistance);
	}

	FVector GetWorldForwardVectorAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetWorldForwardVectorAtSplineDistance(SplineDistance);
	}

	FTransform GetRelativeTransformAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeTransformAtSplineDistance(SplineDistance);
	}

	FVector GetRelativeForwardVectorAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeForwardVectorAtSplineDistance(SplineDistance);
	}

	FVector GetRelativeLocationAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeLocationAtSplineDistance(SplineDistance);
	}

	FQuat GetRelativeRotationAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeRotationAtSplineDistance(SplineDistance);
	}

	FVector GetRelativeScale3DAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeScale3DAtSplineDistance(SplineDistance);
	}

	FVector GetRelativeTangentAtSplineDistance(float SplineDistance) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeTangentAtSplineDistance(SplineDistance);
	}

	float GetClosestSplineDistanceToWorldLocation(FVector InWorldLocation) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetClosestSplineDistanceToWorldLocation(InWorldLocation);
	}

	FVector GetClosestSplineWorldLocationToWorldLocation(FVector InWorldLocation) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetClosestSplineWorldLocationToWorldLocation(InWorldLocation);
	}

	FQuat GetClosestSplineWorldRotationToWorldLocation(FVector InWorldLocation) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetClosestSplineWorldRotationToWorldLocation(InWorldLocation);
	}

	FTransform GetClosestSplineWorldTransformToWorldLocation(FVector InWorldLocation) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetClosestSplineWorldTransformToWorldLocation(InWorldLocation);
	}

	float GetSplineDistanceAtSplinePointIndex(int SplinePointIndex) const override
	{
		CheckUsableGameplaySpline();
		return Super::GetSplineDistanceAtSplinePointIndex(SplinePointIndex);
	}

	int GetNumSplinePoints() const override
	{
		CheckUsableGameplaySpline();
		return Super::GetNumSplinePoints();
	}

	FSphere GetSplineBounds() const override
	{
		CheckUsableGameplaySpline();
		return Super::GetSplineBounds();
	}

	FBox GetRelativeBoxContainingEntireSpline() const override
	{
		CheckUsableGameplaySpline();
		return Super::GetRelativeBoxContainingEntireSpline();
	}

#endif
};

namespace CookChecks
{

// Show an error message if the specified spline is editor only and can't be used for gameplay
void EnsureSplineCanBeUsedOutsideEditor(UObject User, UHazeSplineComponent Spline, bool bRetrievedFromActor = true)
{
#if EDITOR
	if (Spline == nullptr)
		return;
	if (!Spline.bIsEditorOnly)
		return;

	if (bRetrievedFromActor)
	{
		auto PropLine = Cast<APropLine>(Spline.Owner);
		if (PropLine != nullptr)
		{
			if (!PropLine.bGameplaySpline)
				devError(f"{User.Name} is using spline from {PropLine.ActorLabel} for gameplay, but the propline does not have `Gameplay Spline` checked!\nThis will break cooked.");
			return;
		}
	}

	devError(f"{User.Name} is using an editor-only spline component for gameplay, this will break cooked. Spline: {Spline.GetPathName()}");
#endif
}

};

#if EDITORONLY_DATA
struct FPropLineUpdateScope
{
	APropLine PropLine;
	bool bPreviousUpdating = false;

	FPropLineUpdateScope(APropLine InPropLine)
	{
		PropLine = InPropLine;
		bPreviousUpdating = PropLine.bIsPropLineUpdating;
		PropLine.bIsPropLineUpdating = true;
	}

	~FPropLineUpdateScope()
	{
		if (PropLine != nullptr)
			PropLine.bIsPropLineUpdating = bPreviousUpdating;
	}
}
#endif